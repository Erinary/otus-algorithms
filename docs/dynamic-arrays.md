### Сравнение работы динамических массивов при вставке по порядку

| Число элементов (capacity) | SingleArray | VectorArray(20) | VectorArray(100) | FactorArray(5) | MatrixArray(20) | MatrixArray(100) | ArrayListWrapper |
|----------------------------|-------------|-----------------|------------------|----------------|-----------------|------------------|------------------|
| 100                        | 0 ms        | 0 ms            | 0 ms             | 0 ms           | 0 ms            | 0 ms             | 0 ms             |
| 1000                       | 3 ms        | 0 ms            | 0 ms             | 0 ms           | 1 ms            | 0 ms             | 0 ms             |
| 10000                      | 171 ms      | 23 ms           | 4 ms             | 2 ms           | 6 ms            | 2 ms             | 4 ms             |
| 100000                     | 4257 ms     | 504 ms          | 151 ms           | 9 ms           | 68 ms           | 15 ms            | 9 ms             |
| 1000000                    | \> 10 min   | 224818 ms       | 72360 ms         | 92 ms          | 2288 ms         | 241 ms           | 85 ms            |
| 3000000                    | -           | -               | -                | 216 ms         | 117883 ms       | 1474 ms          | 272 ms           |

Наилучший результат показали реализации FactorArray и обертка над ArrayList из стандартной библиотеки. Судя по коду, в 
стандартной реализации так же используется некоторый фактор, вычисляемый динамически, на который увеличивается 
вместимость массива при его расширении (ArrayList::newCapacity).
Немного хуже себя показывает MatrixArray (внутри имеет VectorArray), но тут есть зависимость от заданной вместимости: 
увеличили в 5 раз, и время работы сильно уменьшилось на больших числах. В самом VectorArray эта зависимость тоже наглядно
проявляется, хоть и разница в результатах не так впечатляет - все-таки здесь приходится делать полную копию массива, когда
достигается лимит (а в MatrixArray просто создается "новая строчка").
И замыкает список SingleArray, который пересоздает массив на каждом добавлении нового элемента - звучит неэффективно, 
результат показывает такой же :)
